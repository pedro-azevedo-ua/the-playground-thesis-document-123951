\chapter{Methodology}

Developing a platform to help basketball players organize games and enhance their satisfaction at public courts requires a development process that consistently prioritizes user needs.
To achieve this, the project adopts a User-Centred Design (UCD) ensuring that the users are involved throughout the design process. 
The UCD is applied across three iterations with each culminating in direct user evaluation.
The iterative structure is complemented by Scrum, an Agile project management framework that promotes adaptive planning and continuous improvement, and Acceptance Test-Driven Development (ATDD), ensuring that the system's features align with user expectations and perform as intended.
This chapter details the methodologies, tools and frameworks that are going to be used and followed during the design and development process, and the architecture that the platform will have.



\section{User-Centered Design (UCD)}\label{sec:ucd}

UCD is an iterative process focused on the users and theirs needs in each design phase, by actively involving users in the process.
The goal of UCD is to address the whole user experience, and shape the application to the specific needs of target users\cite{IxDF2025}

To implement UCD systematically, there are 4 phases defined by the \textit{ISO 9241-210:2019}\cite{iso9241-210}, which establish Human-Centred Design (HCD) principals applicable to UCD.
While the standards focus on HCD, UCD applies these principals with explicit focus on a defined target user population rather than broader human contexts. The four phases are:

\begin{itemize}
	\item \textbf{Understand and specify the context of use}: This phase focuses on understanding the target users, their needs, pain points, and the environment in which they will use the system. Research methods such as user interviews, observations, and contextual analysis are employed to build a comprehensive understanding of user contexts;
	
	\item \textbf{Specify the user requirements}: With a clear understanding of users and their contexts, this phase involves gathering and documenting specific user requirements and desired features. 
	Requirements are derived from user research findings and articulate what the system must do to address identified user needs. 
	Requirements are a set of guidelines that state what the functionality and capabilities of the platform system, which meet the user's needs and business's objectives.
	This will guide the development process, ensuring the end product is user-friendly, accessible and valuable.\cite{requirementsIDF}
	
	\item \textbf{Produce design solutions to meet user requirements}: Based on validated user requirements, design solutions are created to address identified needs. This phase includes creating wire frames, prototypes, and mock-ups that translate requirements into tangible design artefacts;
	
	\item \textbf{Evaluate the designs against requirements}: Prototypes and design solutions are tested with actual users to validate that the designs meet specified requirements and user needs. Feedback from evaluation informs iterative refinements until user satisfaction and requirement fulfilment are achieved.
\end{itemize}


\section{Scrum}\label{sec:scrum}

Scrum is an Agile framework that helps developing complex project by organizing work into smaller, iterative cycles called Sprints\cite{scrumAtlassian}.
The Agile methodology, which Scrum implements, divide development into phases that enables adaptive planning, rapid execution and continuous evaluation\cite{agileAtlassian}.
This approach emphasizes planing only necessary work and delivering small, frequent increments while gathering feedback in each cycle which will be integrated into the next phase\cite{agileAtlassian}.
While multiple Agile frameworks exist, Scrum is the most widely adopted due to its flexibility and applicability across projects different scales\cite{scrumAlternatives}.

In this project, requirements gathered during the second phase of UCD (Section \ref{sec:ucd}) are documented as User Stories.
User Stories employ non-technical language to provide development context written from the user's perspective, clarifying not only what is being built, but also the why and the value it delivers.
User Stories integrate naturally into Scrum, where each story is assigned to a Sprint and marked as complete when users can successfully execute the outlined task\cite{userStoriesAtlassian}.
This approached focused on the user aligns with the project's emphasis on User-Centred Design throughout development.

To help implement Scrum effectively, this project uses Jira as a project management tool\cite{jira}, enabling systematic planning, task assignment, and progress tracking in the development phase

\section{Acceptance Test-Driven Development (ATDD)}\label{sec:atdd}

While Scrum (Section \ref{sec:scrum}) provides a framework for project management and the User Stories capture requirements, ATDD is a development methodology in which, acceptance test are written for each User Story before implementation\cite{agileAllianceATDD}.
This ensures that requirements are precisely defined and verifiable with the tests serving as executable specifications of expected behaviour. 
ATDD follows a test-first approach, acceptance tests are written first to define the expected behaviour, the feature is then implemented to satisfy these tests, and finally, the functionality is validated to ensure all tests pass.
Acceptance Test can be written in different ways, scenario-oriented that uses a Given/When/Then template and  a rule-oriented that is a check-list\cite{acceptanceCriteria}, which is the one being use in this project.


\section{Iteration Development Process}

This project follows an iterative and incremental development model structured into three iterations, each integrating UCD, Scrum and ATDD methodologies, and culminating in user evaluation to maintain User-Centred Design principals throughout development

\subsubsection{Iteration 1: Prototype and Feature Validation}

The first iteration includes all four phases of UCD (Section \ref{sec:ucd})

\begin{itemize}
	\item A survey is conducted to understand the basketball players who uses public courts, including their habits, challenges and desired improvements to their experience. With that, \textit{personas} are created representing different user needs and pain points. User scenarios are also developed for each \textit{persona}, describing how they use public courts, what problems they encounter and when and how a platform would support them;
	
	\item Through the \textit{personas} and theirs scenarios, requirements are gathered to respond to their needs, documenting them as User Stories and added to the Jira project Backlog;
	
	\item The prototypes of  user stories are created in Figma to provide an interactive and testable design;
	
	\item Finally, users test the interactive prototype and provide feedback on the importance and relevance of the features. This feedback is use to update and prioritize the backlog for the next iterations.
	
\end{itemize}

In this first iteration, the test that users will perform are Task-based usability testing using interactive Figma prototype, followed by a Feature Prioritization Survey assessing feature importance and relevance;

\subsection{Iteration 2: MVP Development and UI/UX Evaluation}

In the second iteration, instead of a prototype, a Minimum Viable Product (MVP) is developed, with enough features to be usable in early stages and receive feedback.
This iteration start applying both Scrum and ATDD methodologies (Sections \ref{sec:scrum} and \ref{sec:atdd})  to implement the most critical user stories identified from the first iteration's feedback

For each user story, it is follow the ATDD approach, where acceptance criteria are defined, tests are written to validate these criteria, the feature is developed and then validated ensuring all tests pass.
User stories are organized into sprints according to the Scrum framework, enabling iterative and continuous progress, tracking in Jira.

With a functional MVP, users evaluate the platform focusing on user experience (UX) and user interface (UI) aspects, through Task-Based Usability Testing to measure task performance, System Usability Scale (SUS) questionnaire combined with think-aloud protocol during task execution, and User Experience questionnair, providing feedback to guide refinements in the final iteration.

\subsection{Iteration 3: Complete Application and Overall Evaluation}

Following feedback from the second iteration, in the final one it is developed the complete platform, continuing to apply Scrum and ATDD. 
Improvements from previous feedback are made and all remaining user stories are implemented, developing as well the tests first, ensuring consistent quality.
Users conduct a comprehensive evaluation of the complete platform, assessing overall functionality, usability, reliability and satisfaction with th final product, using SUS, task-based testing, and semi-structured interviews.

\section{Architecture}

In Android Developers "Guide to app architecture"\cite{guideArchitecture}, it is recommended an architecture, that includes at least two layers, the UI Layer and the Data Layer, and optionally the Domain Layer.

The UI Layer, or presentation layer, as the name implies, is the user interface and will display the application data on the screen, which should be updated whenever the data changes, either through user interaction or external events.
This layer includes UI elements that render the data on the screen and state holders in order to keep and expose data to the UI, handling logic.

The Data layer, contains business logic that determines how the application creates, stores and changes data.
This layer has repositories, that are classes responsible to expose data to the rest of the application, centralizing changes to the data resolving conflicts between data sources and abstracting the data sources.
These data sources, also included in the data layer, are responsible of working with only one source of data, this being a file, database, network source.

The optional Domain Layer, sits between the UI and Data layers, encapsulating complex business logic or simpler logic which is reused by multiple view models.
Classes on this layer are usually called "use cases" or "interactors" being responsible for a single functionality or user story.

For this project it was followed this guide and, besides that, it will use the Model-View-Model (MVVM) pattern, where there is a clear separation between the logic and the UI, enabling a better development, testing and a clean code base.
The View is responsible for the UI and the presentation to the user, it informs the ViewModel of user actions, and observes the ViewModel states, not contain any application logic, while the ViewModel exposes the data that the View is observing, serving a link between the Model and the View. Finally, the Model abstracts the data sources, working together with ViewModel to get and save data, has the business logic of the application. This can be represented in the layers, with the UI components being the View, and the Domain and Data layer being the Model. 

\begin{figure}[h]
	\caption{Architecture Diagram of the Multiplatform Application}
	\centering
	\includegraphics[width=0.5\textwidth]{figs/architectureDiagram}
	\label{fig:architecture}
\end{figure}

The Figure \ref{fig:architecture} represents the project's architecture and some technologies that will be used, decided after the gathering of requirements.
In the Presentation Layer there is the UI components will be developed using Compose Multiplatform, and  the ViewModel, classes that hold states of the application and exposes them to the View.
The ViewModel will call the Use Cases, in the Domain Layer which use entities and the repositories interfaces to connect with the data layer. 
Here will be use Kotlin Multiplatform taking advantage of the native capabilities while working in both Android and iOS.

In the Data layer, there are the repositories, as the guide mentions\cite{guideArchitecture} which will work with a local and an external data source.
The local data source will be Room\cite{room}  that is part of Android Jetpack suite, making a good option for this project, being an abstraction of SQLite database, that integrates naturally with flows and coroutines, providing a annotation-based API.
Compare to SQLDelight, a considerable option, it has slight more boilerplate with entities and DAOs, and less control over raw SQL, making debugging complex queries harder. 

For the external data source it will be use the Supabase, an open source MBaaS with several services available that will help with the project, including PostgreSQL Database that can handle complex relationship connections while offering built-in realtime features for realtime updates.
Besides that, it has authentication, storage, and server-side functions, however, lacks native push notifications and mobile analytics, which forces third-party tools integrations.
Supabase can be self-hosted or use theirs services that has different pricing options, with the free tier being enough for this project, as it has a limit of 50,000 monthly active users.
Comparing to others, it is not a "black box" being easy to debug and  has less vendor lock-in, with a PostgresSQL database it can be run anywhere and can be exported.

Using Ktor to communicate with Supabase being a  standard and recommend HTTP client, with multiple examples from Google, Jetbrains and other communities using Ktor as example in Kotlin Multiplatform projects.
Another good option would be the Supabase Kotlin Client, however, this would make the application dependable on Supabase and if later the MBaaS was to be replaced, it would be more complex to migrate.
With this, a little more code needs to be developed with Ktor, than Supabase Kotlin Client, but ideal to not get vendor lock-in.
As some feature of the platform will need to work while the user is off-line or with bad connection, the application will have a synchronization manager that will check what needs to be updated in the local database and resolve conflicts.
Finally a data mapper to convert data from Supabase to the Room database is needed.






