\chapter{Methodology}

Developing a platform to help basketball players organise games and enhance their satisfaction at public courts requires a development process that consistently prioritizes user needs. 
To achieve this, the project adopts User-Centred Design (UCD), ensuring that users are involved throughout the design process integrated with Agile.
 The UCD is applied across three iterative cycles, each culminating in direct user evaluation. 
 This iterative structure is complemented by Scrum, an Agile project management framework that promotes adaptive planning and continuous improvement, and Acceptance Test-Driven Development (ATDD), ensuring that the system's features align with user expectations and perform as intended. 
 This chapter details the methodologies, tools, and frameworks employed during the design and development process (UCD, Agile and the Agile-UCD integration are discussed in the Section \ref{sec:app-dev-meth}), explains how they were applied in practice across the three iterations, as well as the system architecture and the main technology decisions that support it.

\section{Iterative Development and Project Plan}

This project follows an iterative and incremental development model structured into three major phases, each following User-Centered Design principles. 
While Phase 1 focuses entirely on user research and prototyping, Phases 2 and 3 integrate Scrum sprints to incrementally develop and evaluate working features. 
This approach applies UCD's complete research-design-evaluation cycle across the entire project, while using Scrum's sprint structure to organize development work within Phases 2 and 3.
The Figure \ref{fig:roadmap} represents the timeline of the different phases.

\begin{figure}[h]
	\centering
	\includegraphics[width=1\textwidth]{figs/roadmap}
	\caption{Project Development Roadmap}
	\label{fig:roadmap}
\end{figure}


\subsection{User Stories and Sprint Planning}

Requirements gathered during the second phase of UCD (Subsection \ref{subsec:ucd}) are documented as User Stories and integrated into Scrum's Sprint structure. 
User Stories employ non-technical language written from the user's perspective, clarifying not only what is being built, but also the rationale and value delivered\cite{userStoriesAtlassian}.
Normally, each User Story belongs to an Epic as milestones, representing a broader thematic organization, enabling progress tracking against major features.
Each story is assigned to a Sprint and marked as complete when users can successfully execute the outlined task, aligning with the project's emphasis on User-Centred Design throughout development.

Jira\footnote{https://www.atlassian.com/software/jira} serves as the project management tool, enabling systematic planning, task assignment, and progress tracking throughout the development phase.

\subsection{Acceptance Test-Driven Development}

ATDD complements the Scrum framework by ensuring that acceptance tests are written for each User Story before implementation\cite{agileAllianceATDD}.
This ensures requirements are precisely defined and verifiable, with tests serving as executable specifications of expected behaviour. 

The ATDD workflow follows three steps, starting by writing the acceptance tests to define expected behaviour, the feature is then implemented to satisfy these tests, and finally, functionality is validated to ensure all tests pass.
This project employs rule-oriented acceptance criteria using a checklist format\cite{acceptanceCriteria}, which integrates naturally with the User Story structure in Jira.
It could also be written in a scenario-oriented way, using a Given/When/Then template.


\subsection{Phase 1: Prototype and Feature Validation}

The first phase includes all four steps of UCD (SubSection \ref{subsec:ucd}) in order to research the problem, design a proposed solution and evaluate with the possible users.
These are the following steps:

\begin{itemize}
	\item A survey is conducted to understand the basketball players who uses public courts, including their habits, challenges and desired improvements to their experience. With that, \textit{personas} are created representing different user needs and pain points. User scenarios are also developed for each \textit{persona}, describing how they use public courts, what problems they encounter and when and how a platform would support them;
	
	\item Through the \textit{personas} and theirs scenarios, requirements are gathered to respond to their needs, documenting them as User Stories and added to the Jira project Backlog;
	
	\item The prototypes of  user stories are created in Figma to provide an interactive and testable design;
	
	\item Finally, users test the interactive prototype and provide feedback on the importance and relevance of the features. This feedback is used to update and prioritize the backlog for the next iterations.
	
\end{itemize}

In this first phase, the tests that users will perform are Task-based usability testing using interactive Figma prototype, followed by a Feature Prioritization Survey assessing feature importance and relevance;

\subsection{Phase 2: MVP Development and UI/UX Evaluation}

In the second phase, instead of a prototype, a Minimum Viable Product (MVP) is developed, with enough features to be usable in early stages and receive feedback.
This phase starts applying both Scrum and ATDD methodologies (Section \ref{sec:app-dev-meth} to implement the most critical user stories identified from the first phase's feedback.

Each user story follows the ATDD approach, where acceptance criteria are defined, tests are written to validate these criteria, the feature is developed and then validated ensuring all tests pass.
User stories are organized into sprints according to the Scrum framework, enabling iterative and continuous progress, tracking in Jira.

With a functional MVP, users evaluate the platform focusing on user experience (UX) and user interface (UI) aspects, through Task-Based Usability Testing to measure task performance, System Usability Scale (SUS) questionnaire combined with think-aloud protocol during task execution, and User Experience questionnaire, providing feedback to guide refinements in the final phase.

In the Figure \ref{fig:jiraRoadmap} is represented the 5 Epics created that contain the User Stories, as well as the propose sprint planning, where from the sprint 1 to 4 is the Phase 2 following a break to test, and sprint 5 and 6 represent the Phase 3 (the attribution of the User Stories to each sprint can be adjusted during its development, depending on the its progress ). 
The Epic prioritization follows a dependency-driven and value-driven approach.
For this second phase it is more focuses on delivering the minimum feature set required to validate the core value proposition, enabling players to discover courts and organize games. 

\textit{User Profile and Settings (PLY-9)} is developed first in Sprint 1, as authentication and profile management are foundational requirements for all subsequent features.
\textit{Court Availability (PLY-6)} is also initiated in Sprint 1, establishing the court discovery infrastructure that is fundamental to game creation.
Sprints 2 implements \textit{Game Management (PLY-5)}, which represents the application's primary value, by creating, browsing, joining, and managing basketball games. 
This sequence ensures that users can complete the core user journey from registration through game participation, enabling meaningful usability evaluation.
In Sprint 3 and 4 is developed features from the different Epics that are not necessary for the main functionality but still adds important value for the application, including adding team and ranking system from the Epic \textit{Ranking and Team System (PLY-8)}. 

\begin{figure}[h]
	\centering
	\includegraphics[width=1\textwidth]{figs/jiraSprintsRoadmap}
	\caption{Epics and Sprint planning in Jira}
	\label{fig:jiraRoadmap}
\end{figure}


\subsection{Phase 3: Complete Application and Overall Evaluation}

Following feedback from the second phase, in the final one it is developed the complete platform, continuing to apply Scrum and ATDD. 
Improvements from previous feedback are made and all remaining user stories are implemented, developing as well the tests first, ensuring consistent quality throughout.
Users conduct a comprehensive evaluation of the complete platform, assessing overall functionality, usability, reliability and satisfaction with the final product, using SUS, task-based testing, and semi-structured interviews.

Continuing the analysis of the Figure \ref{fig:jiraRoadmap}, this phase stars in sprint 5 and it adds value to the \textit{Game Management (PLY-5)} Epic and a chat function from the Epic \textit{Players and Social Features (PLY-7)}


\section{Architecture}

For this project, is followed the Android Developers "Guide to app architecture"\cite{guideArchitecture}, which recommends an architecture, that includes at least two layers, the UI Layer and the Data Layer, and optionally the Domain Layer, that separates the presentation logic, business logic, and data management concerns across the application.

%In Android Developers "Guide to app architecture"\cite{guideArchitecture}, it is recommended an architecture, that includes at least two layers, the UI Layer and the Data Layer, and optionally the Domain Layer.

%The UI Layer, or presentation layer, as the name implies, is the user interface and will display the application data on the screen, which should be updated whenever the data changes, either through user interaction or external events.
%This layer includes UI elements that render the data on the screen and state holders in order to keep and expose data to the UI, handling logic.

%The Data layer, contains business logic that determines how the application creates, stores and changes data.
%This layer has repositories, that are classes responsible to expose data to the rest of the application, centralizing changes to the data resolving conflicts between data sources and abstracting the data sources.
%These data sources, also included in the data layer, are responsible of working with only one source of data, this being a file, database, network source.

%The optional Domain Layer, sits between the UI and Data layers, encapsulating complex business logic or simpler logic which is reused by multiple view models.
%Classes on this layer are usually called "use cases" or "interactors" being responsible for a single functionality or user story.

Besides that, the project will follow the Model-View-Model (MVVM) pattern, where there is a clear separation between the logic and the UI, enabling a better development, testing and a clean code base.\cite{mvvm}
%The View is responsible for the UI and the presentation to the user, it informs the ViewModel of user actions, and observes the ViewModel states, not contain any application logic, while the ViewModel exposes the data that the View is observing, serving a link between the Model and the View. Finally, the Model abstracts the data sources, working together with ViewModel to get and save data, has the business logic of the application. This can be represented in the layers, with the UI components being the View, and the Domain and Data layer being the Model. 

\begin{figure}[h]
	\centering
	\includegraphics[width=1\textwidth]{figs/architectureDiagram}
	\caption{Architecture Diagram of the Multiplatform Application}
	\label{fig:architecture}
\end{figure}

The Figure \ref{fig:architecture} represents the project's architecture and some technologies that will be used, decided after the gathering of requirements.
In the Presentation Layer there is the UI components will be developed using Compose Multiplatform, and  the ViewModel, classes that hold states of the application and exposes them to the View.
The ViewModel will call the Use Cases, in the Domain Layer which use entities and the repositories interfaces to connect with the data layer. 
Here will be use Kotlin Multiplatform taking advantage of the native capabilities while working in both Android and iOS.

In the Data layer, there are the repositories, as the guide mentions\cite{guideArchitecture} which will work with a local and an external data source.
The local data source will be Room\cite{room}  that is part of Android Jetpack suite, making a good option for this project, being an abstraction of SQLite database, that integrates naturally with flows and coroutines, providing a annotation-based API.
Compare to SQLDelight, a considerable option, it has slight more boilerplate with entities and DAOs, and less control over raw SQL, making debugging complex queries harder. 

For the external data source it will be use the Supabase, an open source MBaaS with several services available that will help with the project, including PostgreSQL Database that can handle complex relationship connections while offering built-in realtime features for realtime updates.
Besides that, it has authentication, storage, and server-side functions, however, lacks native push notifications and mobile analytics, which forces third-party tools integrations.
Supabase can be self-hosted or use theirs services that has different pricing options, with the free tier being enough for this project, as it has a limit of 50,000 monthly active users.
Comparing to others, it is not a "black box" being easy to debug and  has less vendor lock-in, with a PostgresSQL database it can be run anywhere and can be exported.

Using Ktor to communicate with Supabase being a  standard and recommend HTTP client, with multiple examples from Google, Jetbrains and other communities using Ktor as example in Kotlin Multiplatform projects.
Another good option would be the Supabase Kotlin Client, however, this would make the application dependable on Supabase and if later the MBaaS was to be replaced, it would be more complex to migrate.
With this, a little more code needs to be developed with Ktor, than Supabase Kotlin Client, but ideal to not get vendor lock-in.
As some feature of the platform will need to work while the user is off-line or with bad connection, the application will have a synchronization manager that will check what needs to be updated in the local database and resolve conflicts.
Finally a data mapper to convert data from Supabase to the Room database is needed.


\subsection{Maps Engine}

An important piece of this project is to have a map identifying the courts for the users to find and visualize.
There are several tools and libraries for this, however the most compatible and cheap option is MapLibre Compose\footnote{https://maplibre.org/maplibre-compose/}.
This is a Compose Multiplatform wrapper around the MapLibre\footnote{https://maplibre.org/} SDKs, an organization that provides open-source mapping libraries, which enables to render interactive maps.
The MapLibre Compose will work in both Android and iOS, and it is possible to configure gestures, respond to a map click or long click, download offline images and more other features.

A disadvantage of this library is that the community and support is still growing.
An alternative would be Google Maps SDK\footnote{https://developers.google.com/maps/documentation/android-sdk/overview?section=start}, however, it has vendor lock-in, with costs passing the USD 300 trial credits.
Besides that, it is not Kotlin Multiplatform native, needing a platform-specific implementation.
Mapbox\footnote{https://www.mapbox.com/} is another option, with a free tier and then price, with no direct support to KMP.

MapLibre Compose is utilized strictly as a Presentation Layer component. 
It functions as a UI rendering engine responsible for visualizing geospatial data provided by the ViewModel. 
It is decoupled from business logic and data access, ensuring that the underlying domain rules regarding court management remain agnostic to the specific mapping technology employed.

MapLibre also integrates with the Data Layer, which handles the retrieval of map tiles from external MapLibre servers. 
When the user interacts with the map (panning, zooming, or changing location), it makes API calls to MapLibre to fetch the necessary map tile data for the requested coordinates and zoom level. 
Additionally, the it implements caching strategies to store map assets locally, enabling offline map functionality. 
It also manages map styling configurations by fetching and applying the MapLibre style JSON, which defines layer styles, colours, and visual properties.


\subsection{Notifications Engine}

To keep user's engagement, it is essential to have notifications, when they are in the application and when they have the application closed, so they get notified when someone has created a game in their favourite court.
Supabase have a real-time feature that enables to create in-app notifications, however, when the application is closed there it is no communication between the Supabase backend and the client side.
For push notifications for when the application is closed, there are different options.
Google's Firebase has the Firebase Cloud Messaging (FCM)\footnote{https://firebase.google.com/docs/cloud-messaging} that can notify the application about available synchronizations, and send notification messages to single devices, to groups of devices, or to devices subscribed to topics, all this with no costs.
Another option is OneSignal\footnote{https://onesignal.com/} that has multiple functionalities including sending notifications when the application is closed.
OneSignal has some pricing options, but in the free tier, the push notifications are unlimited.
For this project, OneSignal will be use, as the set-up is easier because it handles user's tokens while in Firebase, it needs more code to handle user's tokens.

OneSignal integrates with the Data Layer, which handles push notification functionality.
When a user creates a game, for example, the application makes an API call to OneSignal to send a push notification to users. 
By isolating notification logic in the Data Layer, the architecture remains agnostic to the specific notification provider, allowing future migration to alternative services without impacting business logic.
