
\chapter{State of the Art \& Related Work}

\section{Mobile Application Implementation Technologies}
This platform has to reach the maximum basketball players for it to work properly, and should work when the players are in the court, or anywhere.
In order to achieve this, the platform should be access from the mobile phones, and Statcounter Global Stats reports that in Portugal in September 2025, the Mobile Operating System Market Share has 65.65\% Android users and 33.94\% iOS\cite{statcount}.
Despite the fact that more than half of people uses Android, the goal is still reach the maximum players possible, so the platform should be accessible from Android and iOS phones.

In order to develop a mobile application for both platforms, there are different options of approaches that can be selected for the implementation, which are the native, cross-platform, web, hybrid, modeling, cloud-based and merged approaches\cite{Khachouch2020}.

\subsection{Native Apps}\label{subsec:native-apps}

Going Native, means that the app will be developed with to a specific OS, using its programming language.
To build native Android applications, developers typically use Kotlin or Java.
Both language are compiled to Java Bytecode that runs on the Android Runtime (ART).
As for iOS, developers use Swift or Objective-C, mainly the first one, to build native iOS applications.

Unlike other solutions that add abstraction layers (like React Native or Flutter), native applications compile directly to the platform's native language. 
This results in better performance and faster execution compare to other solutions, which will be discussed later.
In addition to performance, native development offers security benefits, since developers can take advantage of the built-in security features of the operating system.
When it comes to User Interface (UI) and User Experience (UX), each platform provides its own guidelines where Android follows Material Design, while iOS the Human Interface guidelines.
This consistency makes apps easier to navigate, and there is no issues in the app adaptation to other devices.\cite{Nagy2022}
Finally, native applications provide superior direct access to the device's complete hardware and sensor ecosystem, including the camera, microphone, GPS, accelerometer, gyroscope and more\cite{Nagy2022}.
This type of access enables full integration with device features for enhanced functionality, and can give better recognize user activity and environmental conditions, enabling the app to infer user context (for example, distinguishing activities like walking or running) by processing sensor data locally on the device\cite{santos}.

When the goal is to deliver an application for both Android and iOS using native development, each feature must be implemented twice, once for each platform and in different programming languages.
As Robert Nagy explains in \textit{Simplifying Application Development with Kotlin Multiplatform Mobile}\cite{Nagy2022}, the development cost of this approach can be expressed as:


\[Cost of development (n) = n * FC\]

where \textit{n} represents the number of platforms and \textit{FC} the \textit{feature complexity}, defined as the sum of all sub-features that compose a feature.
With this expression, when the number of features 

Nagy notes that this formula and its graphical representation are approximations that describe reality simplistically, intended to illustrate the cost differences between development approaches rather than provide precise metrics.\cite{Nagy2022} 
The core insight is that native development costs scale linearly with the number of platforms, as developing for two platforms costs approximately twice as much as developing for one, and three platforms costs three times as much.

Beyond this, additional factors complicate native development.
Each platform has distinct characteristics, and a solution that is straightforward to implement on one platform may be unavailable or significantly harder to achieve on another.
This divergence creates extra overhead in aligning features sets across platforms.
So, Nagy introduces the additional component, \textit{Synchronization Cost}, which increases in an exponential way as the number of features and its complexity grows.
The updated formula is expressed as:

\[Cost of development (n) = n * FC + Sync Cost ^ {FC}\]

\subsection{Web Applications}\label{subsec:web-applications}

Any application that is access through \textit{HTTP} requests over a network is called a web based application.
These applications are implemented with HTML, CSS and JavaScript.
Until Progressive Web App appeared, these applications were browser only, but now, they can be installed in the device, can have offline availability, push notifications and background sync, also able to run on desktop.
Developers normally use Angular or React, and other frameworks are StencilJS or Svelte.
However, PWAs cannot access key platform's features as the Native apps can, and also, has a possible higher energy consumption.\cite{Huber2021}

\subsection{Hybrid Applications}\label{subsec:hybrid-applications}

Another option, also leveraging web technologies such as HTML, CSS and JavaScript, is taking a hybrid approach.
The app is developed with as web app and developers wrap the app via cross-platform wrappers, frameworks and tools, as a native app.
With this approach, the app as a user experience just as a native app.
Some hybrid app frameworks are Cordova, Phonegap, Titanium, Ionic, being the first the most common.
Using third-party plugins with JavaScript, it is possible to access features form the device, such as the camera and GPS\@.
In the Maher Gerges and Ahmed Elgalb article\cite{Gerges2024}, where they compare different approaches, it is compared the hybrid apps directly with the native apps, and, in CPU and Memory occupancy, the hybrid cost more, being 106\% higher and 73.0\% higher in order.
Also, not all features are available and the performance is worse than native applications.\cite{Gerges2024}

\subsection{Cross-Platform Apps}\label{subsec:cross-platform-apps}

In order to avoid repeating the same code for different platforms, there are Cross-Platforms approaches.
With this method, it is possible to create applications that run on multiple operating systems.
In a first look, using cross-platform methods can be an effective solution to develop applications for a multiple platforms, when time, cost and basic interoperability is the primary concern.
On the other hand, Cross-Platform applications tend to have the worst performance and user experience compared with Native apps, as they are behind the evolution of Android and iOS and cannot take full advantage of each platform's features\cite{Nagy2022}.
In different articles and papers, the categorization of the approach varies, especially, when it comes to the Cross-Platform approach, there are subcategories\cite{ELKASSAS2017163}.
The Web and Hybrid approach is normally inserted in this category, alongside with Interpreted approach and Cross-Compiled approach\cite{ELKASSAS2017163}, which the most popular used frameworks are React Native and Flutter, respectively.

\subsubsection{Interpreted Approach - React Native}

Similar to the web and hybrid approach, uses web technologies such as CSS and JavaScript, however, the user interface is not HTML and not render in the browser.\cite{Huber2021}
The most popular used framework is React Native from 2015, developed by Meta, where developers build applications with React components, and the logic in JavaScript.
This framework uses component-based architecture, following the steps of React for the web, promoting code reusability, modularity and easy debug.\cite{10667693}
The JavaScript code executes on a separate thread and communicates with the native layer through a bridge\cite{Nagy2022}, allowing developers performance-critical parts of the app in native languages\cite{10667693}.
The bridge translates asynchronous, serializable data between the two environments, which enables native rendering of components.
However, this approach introduces overhead, resulting in a process generally slower compared to fully native applications.\cite{Nagy2022}

\subsubsection{Cross-Compiled Approach - Flutter}

In this approach, the app is developed in a common language, and then, it is compiled to the native code that can be executed on a mobile device, with Flutter and Xamarin popular examples.\cite{Huber2021}
Flutter is a framework developed by Google, its architecture can be described in three layers\cite{Nagy2022}.
The Framework layer, where developers write the application code and the UI components, declaratively using the Dart language.
The Engine layer renders Flutter widgets to a canvas called Skia Canvas, which is then passed to the final layer, the native platform.
The platform displays the canvas and sends back user events to the framework.\cite{Nagy2022}
Compared to React Native, Flutter often achieves better performance by relying on Android's Native Development Kit and iOS's Low-Level Virtual Machine to compile code coming from the engine, Flutter applications deliver higher execution performance.
Nevertheless, certain parts of a Flutter application may still need to be implemented in Java/Kotlin and Obj-C/Swift code.
Communication between these native components and the Dart code is through a channel, reducing scalability\cite{Nagy2022}.

\subsubsection{Cloud-based Approach and Modelling Approach}

A Cloud-based application, has its backend in the cloud, instead of running locally, using the cloud features such as flexibility, virtualization and security.\cite{ELKASSAS2017163}
Companies like Amazon Web Services, offer that service called Backend as a Service (BaaS).\cite{Khachouch2020}

There are two subcategories in this approach, the Model-Based User Interface Development (MB-UID) and the Model-Driven Development (MDD).
Developers use abstract model to describe tasks, data, users and the user interface, which will generate source code.
It can transform to code from different platforms.
Some tools include XMobile, for MB-UID and JavaScript Application Framework for MDD\cite{Khachouch2020}.

Low-Code Development Platforms represent the modern evolution of MDD principles, combining visual with cloud-based infrastructure and automatic code generation. 
These platforms, including OutSystems, Mendix, Zoho Creator, Lansa, and Salesforce, enable rapid application development through visual drag-and-drop interfaces, pre-built components, and What-You-See-Is-What-You-Get (WYSIWYG) editors.\cite{9908726}

This approach encounter challenges like scalability, model management issues which are important to increase the efficiency of automation, support scalable operations, and for manipulating, querying, and analysing models.
Besides that, optimization of large models and when several dedicated languages are used to carry out different model management strategies, the space and overall complexity increase as the size of the model grows\cite{9908726}



\subsection{Kotlin Multiplatform}\label{subsec:kotlin-multiplatform}

Although cross-platforms the previous frameworks solve the problem of dealing with different platforms, it is still not optimal if the application demands platform specific features, and keeping up with Android and iOS updates.
To address these conditions, developers can choose Kotlin Multiplatform (KMP), also a cross-platform solution.

According to JetBrains documentation, Kotlin Multiplatform is an open-source technology developed by them that enables developers to create applications for multiple platforms efficiently by reusing code across them and still having the native approach benefits\cite{kmp}.
Developers can share code without losing the qualities of native programming, have good user experience, good application performance and having full platform capabilities, alongside the benefits of the cross-platform, reducing development time, consistency in behaviour in the different platforms\cite{Janakaraj2025}.
In this approach, the developer has 3 options, it can share and only write a critical feature in Kotlin, or implement the full logic and only develop the UI natively, and finally, with Compose Multiplatform, also share the UI\cite{kmp}.

Jetpack Compose\footnote{https://developer.android.com/compose} is a tool-kit to develop the User Interface of Android applications.
It is implemented in a declarative way, compatible with Kotlin APIs, enabling developers to intuitively build fast UIs.
It also supports Google's Material Design, an ``open-source design system for building beautiful, usable products''\cite{materialD}.
Since 2021, developers can build shared UIs for Android, iOS, desktop and web, feeling natural on every platform with Compose Multiplatform.\cite{compose-multi}

Thompson Carter, refers in his book\cite{kotlinInDepth} the same benefits of KMP, code re-usability, faster development, reduce maintenance (as it is only need to fix bugs in one place), flexibility (share code and still access platform-specific features and APIs) and community support.
However, he mentions some challenges as:
\begin{itemize}
	\item Maturity, as the KMP is recent and is still evolving, some libraries and tools may not be fully supported;
	\item The integration with Platform-Specific APIs can be challenging;
	\item The transition from single-platform development can be a bit difficult, with the introduction of new paradigms;
	\item And the integration with an existing project can involve significant re-factoring.
\end{itemize}

\subsection{Comparative Analysis}\label{subsec:overview}

On one hand, using cross-platform frameworks can be an effective solution to develop applications for multiple platforms, when time, cost and basic interoperability is the primary concern.
On the other hand, these frameworks tend to be behind the evolution of Android and iOS, and cannot take full advantage of each platform's features.
Robert Nagy therefore refines the development-cost equation as:

\[Cost of Development (n) = FC * (1 + Cost of going Native)\]

In this equation, \textit{n} is the number of platforms and \textit{FC} is the feature complexity.
As for the \textit{Cost of going Native}, it reflects the additional effort required when some parts must be implemented with native code.
This theoretical model assumes that the \textit{Cost of going Native} is not a fixed value, but rather depends on three main factors.
It is important to note that this is a theoretical model without empirical data; instead, Nagy identifies three factors that contribute to the cost:\cite{Nagy2022}

First, the level of interoperability that the cross-platform framework provides with native components, which is typically not optimal.
When developers need to bridge framework code with platform-specific APIs, they must invest time to understand how to properly connect these two different environments.

Second, the knowledge gap between the framework and native languages adds to the expense.
Developers who specialize in the cross-platform framework (e.g., Dart or React) may not be familiar with native languages like Kotlin, Java, or Swift.
Learning these languages and implementing features correctly requires additional time and effort.

Third, synchronization costs arise when maintaining consistency between code written in the framework and code written in native languages.
As the application grows and more native code is added, keeping both implementations synchronized becomes increasingly complex and time-consuming.\cite{Nagy2022}

Besides this a roadblock can occurs when a required feature cannot be implemented only with the framework and must instead be written in native code, producing a sudden increase in cost.
If no native features are required, cross-platform development can remain less expensive compared to native development, despite the discussed limitations.
However, as more features demand native implementation, the cumulative cost eventually exceeds that of a fully native approach.\cite{Nagy2022}

Table \ref{tab:approaches-comprehensive} provides a comparative analysis of mobile development implementation technologies, synthesizing key characteristics, advantages, and disadvantages.
\begin{table}[ht]
	\centering

	\small
	\renewcommand{\arraystretch}{1.4}
	\setlength{\tabcolsep}{8pt}
	\caption{Comparison of mobile application development implementation technologies \cite{Khachouch2020, 10667693, Janakaraj2025}}
	\label{tab:approaches-comprehensive}
	\begin{tabularx}{\textwidth}{|p{3.2cm}|X|X|}
		\hline
		\textbf{Approach} & \textbf{Advantages} & \textbf{Disadvantages} \\ \hline
		
		Native apps & 
		Best performance; full access to platform APIs and sensors; highest UX fidelity; mature tooling and debugging. Very large, established communities; extensive third-party libraries. & 
		Two separate code bases for multiple platforms with significantly higher cost; steep learning curve requiring platform-specific language expertise (Kotlin/Java or Swift). \\ \hline
		
		Web apps / PWAs & 
		Single code base; runs on desktops and mobile browsers; easy distribution via web. Massive developer community using standard web technologies; low learning curve building on existing web knowledge; no licensing costs. & 
		Limited access to native features and device sensors; performance and energy use vary significantly depending on internet connection; difficult to monetize; cannot be published in app stores. \\ \hline
		
		Hybrid (wrapped web) & 
		Faster port from existing web applications to installable apps; single web code base; plug-in ecosystems (Cordova, Capacitor) enable device feature access; large, active community; builds on web development skills. & 
		Worse performance than native due to WebView execution; higher CPU and memory usage; some native features unavailable; UX can feel non-native; ecosystem declining in adoption. \\ \hline
		
		React Native (interpreted) & 
		High code reuse across platforms; strong React ecosystem with extensive third-party libraries; UI renders using native components improving responsiveness; good developer velocity; very large and active community with strong backing from Meta; MIT license (no vendor lock-in). & 
		Bridge overhead can reduce performance for heavy UI/CPU work; some advanced features require native modules; platform parity depends on third-party library support; more complex debugging. \\ \hline
		
		Flutter (cross-compiled) & 
		Compiled to native code (via Dart) ensuring high performance; consistent UI across platforms via Skia rendering engine; rich, customizable widget set enabling polished UIs; hot reload for fast iteration; rapidly growing community with Google backing; BSD license. & 
		Larger app binary sizes compared to native apps; occasionally needs platform channels for native feature access; requires learning Dart, a less common language; moderate-to-high learning curve. \\ \hline
		
		Model-Driven / Low-Code & 
		Rapid development using visual, declarative modelling; minimal coding required reducing learning curve; pre-built components and services; strong enterprise ecosystem; integrated deployment pipelines and monitoring. & 
		Moderate performance compared to compiled native approaches; limited flexibility for complex custom logic; vendor lock-in with proprietary platforms (e.g., OutSystems, Mendix); high licensing costs for enterprise features. \\ \hline
		
		Kotlin Multiplatform (KMP) & 
		Share core business logic (networking, storage, domain rules) across platforms while retaining native UIs or using Compose Multiplatform for shared UI; near-native performance and good interoperability with native code; builds on Kotlin knowledge; Apache 2.0 license; JetBrains backing. & 
		Ecosystem still maturing with potential gaps in third-party libraries; some libraries may be platform-limited; complex when integrating with existing native projects; tooling and ecosystem support are improving. \\ \hline
		
	
	\end{tabularx}
\end{table}



\section{Mobile Application Development Methodologies}\label{sec:app-dev-meth}

While the selection of implementation technologies determines the technical foundation for mobile application development, the development methodology shapes how the entire development process is organised, executed and iterated upon.
The methodology addresses how the work is structured, planned and managed throughout the project life-cycle.

Mobile application development present distinct challenges that differ from traditional software development, due to rapid platform evolution, device fragmentation, high user expectations for performance and usability, frequent update cycles, and the need for continuous adaptation to changing requirements and user feedback.
Consequently, development methodologies specifically designed for mobile contexts have emerged, alongside adaptations of established software development approaches.

\subsection{Agile}

Agile Software Development is an alternative methodology to traditional ones, responding to their limitations.
This methodology is centred on four core values such as prioritizing individuals and interactions over processes and tools, working software over comprehensive documentation, customer collaboration over contract negotiation, and responding to change over following a plan\cite{agile-manifesto}.

The Agile Manifesto\cite{originalAgileMani} also provides twelve principals in order to follow the four core values.
These principles prioritize satisfying customers through early and continuous delivery of valuable software, and embrace changing requirements even late in development.
They emphasize delivering working software at frequent intervals with shorter time-scales, supported by daily collaboration between business people and developers.
Teams should be built around motivated individuals with proper environment and support, using face-to-face communication as the primary method of information exchange.
Working software is the primary measure of progress, and sustainable development pace should be maintained continuously.
The principles further stress continuous attention to technical excellence and good design, while maximizing simplicity by minimizing unnecessary work.
Finally, self-organizing teams are encouraged to emerge with the best architectures and designs, and teams should regularly reflect on their effectiveness to adjust their practices.\cite{agile-manifesto} 

With Agile core values and principals, challenges like the static nature of requirements specifications and the disconnection between initial planning and actual user needs are mitigated.
Agile embraces iterative and incremental development. Work is organized into short cycles called sprints or iterations, during which teams deliver working software increments. This approach enables rapid feedback from users and stakeholders, allowing requirements to evolve and be re-prioritized continuously throughout the development process.\cite{agile-manifesto} 

Agile has frameworks that help putting this principals to work.
There is Scrum, that provides a structured approach with defined roles (Product Owner, Scrum Master, Development Team), time-boxed sprints, and ceremonies (daily, sprint planning, retrospectives) that maintain team organization and accountability. 
To offer a more continuous flow approach, there is Kanban that visualises the work on a board with columns representing stages (To-Do, In Progress, Done), allowing teams to prioritize dynamically and limit work-in-progress.
Extreme Programming (XP) emphasizes technical practices such as pair programming, test-driven development, continuous integration, and collective code ownership to maintain code quality and enable rapid, frequent releases.
There are other methodologies that provide specific practices and focus areas, but all share the core values of the Agile Manifesto. \cite{agile-manifesto} 

However, Agile methodologies present a significant challenge regarding usability and user experience.
Agile was primarily designed by and for developers, focusing on implementation practices rather than interaction design or user research.
Consequently, usability and user experience quality are often treated as secondary concerns,without being planned systematically.
Research has shown that Agile teams frequently de-prioritize usability activities such as user testing, assuming such activities consume too much time within tight sprint schedules.
Additionally, the role of usability in software development is often unclear within agile teams, leading to instances where teams either neglect usability entirely or implement it incorrectly.\cite{10795519}

As Mobile development requires a better usability and user experience focus, Agile must work with User-Centred Design.

\subsection{User-Centred Design (UCD)}\label{subsec:ucd}

User-Centred Design (UCD) is a development philosophy that positions usability as a primary goal rather than an afterthought. 
Usability, defined as the degree to which a system can be used by a specific type of user in a specific context to achieve specific goals, is particularly critical for mobile applications. 
The mobile form factor introduces unique design constraints that fundamentally differ from desktop, like the shape and size of screens restrict how information can be displayed, input methods favour certain interactions over others, .and their portability enables use across diverse environments and contexts, including situations where the user's attention may be divided.\cite{10795519}

UCD is an iterative process focused on the users and theirs needs in each design phase, by actively involving users throughout the process.
The goal of UCD is to address the whole user experience, and shape the application to the specific needs of target users\cite{IxDF2025}
To implement UCD systematically, there are 4 phases defined by the \textit{ISO 9241-210:2019}\cite{iso9241-210}, which establish Human-Centred Design (HCD) principals applicable to UCD.
While the standards focus on HCD, UCD applies these principals with explicit focus on a defined target user population rather than broader human contexts. The four phases are:

\begin{itemize}
	\item \textbf{Understand and specify the context of use}: This phase focuses on understanding the target users, their needs, pain points, and the environment in which they will use the system. Research methods such as user interviews, observations, and contextual analysis are employed to build a comprehensive understanding of user contexts;
	
	\item \textbf{Specify the user requirements}: With a clear understanding of users and their contexts, this phase involves gathering and documenting specific user requirements and desired features. 
	Requirements are derived from user research findings and articulate what the system must do to address identified user needs. 
	Requirements are a set of guidelines that state what the functionality and capabilities of the platform system, which meet the user's needs and business's objectives.
	This will guide the development process, ensuring the end product is user-friendly, accessible and valuable.\cite{requirementsIDF}
	
	\item \textbf{Produce design solutions to meet user requirements}: Based on validated user requirements, design solutions are created to address identified needs. This phase includes creating wire frames, prototypes, and mock-ups that translate requirements into tangible design artefacts;
	
	\item \textbf{Evaluate the designs against requirements}: Prototypes and design solutions are tested with actual users to validate that the designs meet specified requirements and user needs. Feedback from evaluation informs iterative refinements until user satisfaction and requirement fulfilment are achieved.
\end{itemize}

\subsection{Agile User-Centred Design Development (AUCD)}

The integration of Agile with UCD attempts to leverage the strengths of both methodologies to create development processes that deliver usable software rapidly while maintaining focus on user needs throughout the project lifecycle.
Integration attempts can range from simply including usability techniques in the Agile process to implementing comprehensive frameworks.
For that, there is two distinct structures to incorporate UCD into the Agile workflow, where the fist is referenced as \textit{one sprint ahead} and the other \textit{within iteration}.\ref{10795519}

The \textit{one sprint ahead} makes the team responsible for the design to work in a different sprint than the developers.
While sprint two is being developed, sprint one is being tested and the sprint three is being design.
This potentially can decrease agility as difficult to accepting changes during the development process rises.
As for the \textit{within iteration}, as the name implies, the design artefacts are developed in the same iteration they are produced.\ref{10795519}

Mobile application development using Agile-UCD employs a range of UCD techniques tailored to project needs and constraints.
User-testing is the most use following this study \cite{10795519}, different types of prototypes (functional, mock-up, paper, wire-frame) are also included in this Agile-UCD integration.


\section{Mobile Backend Development Strategies}\label{subsec:backend-strategies}

\subsection{Backend Fundamentals}
Mobile Applications follow a distributed architecture that has 2 components, front end and the back end.
The front end, also called the client-side is the part of the application that runs locally in the user's device.
This is the User Interface, presentation logic and can have part of the business logic, that can be developed with Compose Multiplatform and Kotlin Multiplatform, for example.
The back end, also called server-side, is executed outside the device, which the user does not interact with directly.
This component can handle the data, reading, writing, updating, and delete data from the database, authenticate users, and more.

De Carli (2023, Chapter 2: ``Introduction to Firebase'') describes a traditional mobile architecture example\cite{DeCarli2023}.
He uses the Figure ~\ref{fig:tradicionalBackend} to represent an iOS application that has the Front-end, the user interface code in Swift (see subsection ~\ref{subsec:native-apps}), the back end that can manipulate data coded in Ruby or Node.js, and a cloud service, that distributes the data in the cloud (Microsoft Azure, AWS, Google Cloud).
He mentions that the application communicates with a virtual machine that can be coded in Ruby, Node.js or even PHP, that is hosted by a cloud service or, less common now, in a physical server.
This is a traditional back end, which, in a complex application is usually required to have separate developers for each part of the application, including a back end developer to code the logic and APIs, and a DevOps to distribute in the cloud\cite{DeCarli2023}.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\textwidth]{figs/tradicionalBack}

	\caption{An iOS app built with a back end host on a cloud service\cite{DeCarli2023}}
	\label{fig:tradicionalBackend}
\end{figure}

However, a different strategy for the backend, that is more recurrent for developers that what to focus on the application development, is the use of Backend as a Service (BaaS) or Mobile Backend as a Service (MBaaS)\cite{Kuo}.
BaaS is a cloud-based service model that provides back end features and tools needed for the mobile application that are executed in the server, such as user authentication, database, remote updating, and push notifications, as well as cloud storage and hosting\cite{saraf2022}.
Firebase\footnote{https://firebase.google.com/}, is an example of a BaaS, and in the second chapter of Sullivan De Caril' book, he introduces the service and shows the Figure \ref{fig:firebaseBack}, that represents the iOS application integrating Firebase.
With this, it is possible to see that the back end is managed by the tool and, as Firebase is from Google, it is also built in Google Cloud, having a simpler architecture.
The application receives data from Firebase using the APIs provided, without needing to write code on the server side or having another provider to host\cite{DeCarli2023}.


\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\textwidth]{figs/firebaseback}
	\caption{An iOS app built with Firebaseâ€™s backend\cite{DeCarli2023}}
	\label{fig:firebaseBack}
\end{figure}


BaaS platforms provide services such as user authentication,  database storage,  cloud functions,  and real-time messaging, that speeds up development cycles and decreases the overhead involved in infrastructure management\cite{ShahJagtapJain2025}.

The disadvantage of these platforms include the lack of flexibility and fine-grained control, specially when the developer has complex data, custom analytics or there is proprietary infrastructure.
Besides that, when choosing a platform, the app developer is subject to vendor lock-in, becoming dependent in the platforms tools, APIs and data formats.
With this, developers can also go for a hybrid approach, using features form the BaaS and developing other back end features with a programming language\cite{ShahJagtapJain2025}.

\subsection{Data management strategies}

In mobile applications, data management is a critical component that directly influences application performance, user experience, and business logic execution. 
The ability to store, retrieve, synchronize, and secure data determines the success of most applications. 
Mobile applications are characterized by specific architectural requirements that differ fundamentally from traditional information systems. 
These characteristics function as explicit data management requirements rather than mere technical preferences, necessitating consideration when designing data management strategies.

Mobile applications serve multiple users who access the same data from diverse devices and platforms (iOS, Android, Web, Desktop). 
This distributed multi-device environment necessitates a centralized Single Source of Truth, an authoritative data repository ensuring all users see consistent, up-to-date information regardless of device or timing of synchronization. 
Local-only storage on individual devices becomes insufficient when multiple devices must maintain synchronized state, as data inconsistencies would fragment the user experience across platforms.\cite{dataLayer}

With multiple users simultaneously accessing, writing, and updating data, applications must maintain real-time synchronization to preserve consistency across all clients. 
A critical challenge emerges when multiple users edit the same data while offline which is conflicting changes that must be resolved upon reconnection.
The application must therefore implement sophisticated conflict resolution strategies to determine the authoritative state when divergent modifications converge during synchronization, which will be analysed in more detailed in the Subsection \ref{subsec:sync}.

Another issue is that network connectivity for mobile users varies significantly across time and environment, ranging from high-bandwidth Wi-Fi to constrained cellular connections to complete offline states. 
Mobile applications cannot assume reliable continuous connectivity. 
Instead, they must adopt offline-first architecture, prioritizing local data availability over network dependency. 
With this approach, the application will remain usable without a reliable network connection, it will present the user with the local data instead of waiting for the first network call to complete or fail, and it will fetch data when the optimal conditions are met\cite{offlineFirst1}.

Mobile devices operate under significant hardware limitations compared to desktop systems, being constrained with processor speed, limited memory, finite local storage capacity, and battery constraints. 
These inherent limitations require data management strategies emphasizing minimal memory footprint, efficient access patterns, data compression techniques, and energy-efficient synchronization protocols.
Database technology selection must prioritize lightweight solutions, ensuring applications consume minimal computational resources while maintaining reliable data persistence.\cite{offlineFirst1}

Mobile applications have a big volume of multimedia, with users continuously capturing  photographs, video recordings, and audio content through integrated device sensors.
Since multimedia files are large and users expect access across all devices, local-only storage becomes impractical and Cloud-based object storage solutions become essential, and fast delivery is important.\cite{FERNANDO201384}

The convergence of these requirements establishes that mobile applications are naturally suited to cloud-based infrastructure, where external providers offer real-time capable databases, bidirectional synchronization, object storage with CDN integration, background task orchestration, and horizontally scalable infrastructure.\cite{offlineFirst1, FERNANDO201384} These constraints and capabilities are particularly visible in Mobile Backend as a Service (MBaaS) platforms, which will be analysed in detail in Subsection \ref{subsec:mbaas}.



\subsection{Data Synchronization}\label{subsec:sync}

With data in local storage and data in an external database, data synchronization is critical in mobile applications that depend on multi-user interaction, collaboration and shared data.
Synchronization ensures that all users and devices have consistent up-to-date information.

Following Zach McCormick and Douglas C.Schmidt paper in data synchronization patters\cite{mccormick}, these patterns can be categorized into data synchronization mechanisms patterns (asynchronous vs synchronous), data storage and availability patterns (partial vs complete), and data transfer patterns (full transfer, timestamp transfer, or delta transfer).

Data synchronization mechanisms patterns address how synchronization operations execute relative to the user interface, with asynchronous synchronization performing data transfers in the background without blocking user interactions, thereby maintaining application responsiveness but requiring careful management of concurrent data modifications.
While synchronous synchronization blocks the user interface until data transfer completes, guaranteeing immediate consistency at the cost of reduced responsiveness.
This synchronous operations are less common, but essential when the users logs in and the system is checking the credentials.

Data storage and availability patterns determine the scope of data maintained on mobile devices, where partial storage retains only a subset of server data based on user needs or device constraints to minimize storage requirements and reduce synchronization overhead.
This is the standard for most resource-constrained mobile applications, such as Google Maps downloading only relevant map tiles on-demand, or an e-reader syncing only the specific books a user is currently reading rather than the entire book store inventory\cite{mccormick}.
Whereas complete storage maintains a full replica of server data on the device, enabling comprehensive offline functionality but demanding greater storage capacity and longer initial synchronization times.
This pattern is exemplified by applications like Dropbox, which allows users to select specific files or folders for upfront synchronization to ensure availability when network connectivity is lost\cite{mccormick}.

Data transfer patterns define what information moves between client and server during synchronization, including full transfer which transmits entire datasets regardless of changes, as one examples in \cite{mccormick} is in an application that displays the top ten news articles for a newspaper issued daily (so that the top ten news articles do not change), with this, the dataset changes every time the application is updated, so it uses Full Transfer.
Timestamp transfer, which exchanges only records modified since the last synchronization by comparing modification timestamps, commonly used by public transit applications to download only route updates, or by social media APIs to fetch posts created "since" the last check.
And delta transfer which computes and transmits only the specific changes or differences between client and server versions, minimizing bandwidth consumption but increasing computational complexity, exemplified by video conferencing application that transmit only the changed pixels between frames to optimize bandwidth.\cite{mccormick}

When data is written locally while offline, there will be differences between the online data, and there will be a conflict that needs to be resolve before synchronization.
There are several conflict resolution strategies, such as Server Wins or Client Wins, where it is decided if the data in the server prevails over the client or the other way, Merge conflict by implementing logic to merge changes when possible with user intervention possible needed with complex data, Vector Clocks when there is a complex scenario, helping understand the relationships between changes\cite{mediuDataSync}. Another method that Androids mentions in its documentation is called Last write wins, where the device adds metadata to the written data in the network, and when the network data source receives, any older data will be discard\cite{dataLayer}. This can result in data loss if two offline devices write conflicting updates sequentially; when both reconnect and synchronize, the data written by the first device will be discarded.

For a good user experience on unreliable networks, an offline-first hybrid architecture is a good option.
Keeping a local databases for immediate responsiveness, use background workers like Android WorkManager\footnote{https://developer.android.com/reference/androidx/work/WorkManager} and iOS Background Tasks\footnote{https://developer.apple.com/documentation/backgroundtasks}, for scheduled synchronization, and Backend as a Service platforms (Google Firebase, AWS Amplify) for cross-device consistency.
Besides that, these background schedulers allow developers to constrain synchronization to unmetered (Wi-Fi) networks only, preventing the application from incurring excessive costs for users in regions where cellular data is expensive or limited\cite{workmanager}.
Such architecture balance responsiveness, bandwidth, and storage while allowing application-level conflict-resolution policies to be enforced.


\subsection{Databases}

There are two fundamentally different approaches to databases in mobile application development, the relational and non-relational databases. 
Relational databases, organize data into structured tables with predefined schemas and utilize Structured Query Language (SQL) for data manipulation, providing strong ACID properties (Atomicity, Consistency, Isolation, Durability) that ensure transactional reliability and data integrity\cite{chiriac2025nosql}.
Non-relational or NoSQL databases employ flexible, schema-less data models that accommodate diverse data types without rigid table structures, offering horizontal scalability and superior performance for unstructured data and high-volume operations~\cite{chiriac2025nosql}.
For mobile applications, some examples of databases include, MySQL\footnote{https://www.mysql.com/}, PostgreSQL\footnote{https://www.postgresql.org/} and SQLite\footnote{https://www.sqlite.org/} as Relational databases.
MongoDB Realm\footnote{https://realm.netlify.app/}, MongoDB\footnote{https://www.mongodb.com/}, Redis\footnote{https://redis.io/}, examples for NoSQL, as well as Firebase Realtime Database\footnote{https://firebase.google.com/docs/database} and Firebase Firestore\footnote{https://firebase.google.com/docs/firestore}, with this two last being a Google Cloud solution.
For local database, usual option are between Room\footnote{https://developer.android.com/training/data-storage/room}, that is an abstraction layer over SQlite, SQLite, Realm or Core Data, Apple's framework for local persistence or cache on iOS\footnote{https://developer.apple.com/documentation/coredata/}.
The selection between these database types depends on specific mobile application requirements such as data structure complexity, offline capabilities, synchronization needs, and scalability projections, with modern applications often employing hybrid approaches that leverage both relational and NoSQL databases for different functional domains\cite{Taipalus2024}.

\subsection{MBaaS Providers}\label{subsec:mbaas}

There are several different solutions to choose for MBaaS, from big cloud corporations such has Google's Firebase, Amazon's AWS Amplify, Microsoft Azure, to open-source like Supabase, Parse, Back4App. Below are some relevant MBaaS:

\subsubsection{\textbf{Google Firebase}}

Firebase is a Backend as a Service developed by Google and built on Google Cloud infrastructure,  that provides various functionalities to help build, deploy and manage mobile a and web applications.
Developers do not need to build APIs, as the platform provides its dedicated Software Development Kit (SDK) to interact with its set of tools.
Here are the following tools that Google's Firebase provide:

\begin{itemize}
	\item \textbf{Cloud Firestore} - is a flexible, scalable database for mobile, web, and server development. It keeps the data in sync across client apps through realtime listeners and offers offline support for mobile and web so developers can build responsive apps that work regardless of network latency or Internet connectivity. Cloud Firestore also offers seamless integration with other Firebase and Google Cloud products, including Cloud Functions.\footnote{https://firebase.google.com/docs/firestore}
	\item \textbf{Cloud Functions} - Firebase is a serverless framework that lets developers to automatically run backend code in response to events triggered by background events, HTTPS requests, the Admin SDK, or Cloud Scheduler jobs. JavaScript, TypeScript or Python code is stored on Google Cloud infrastructure and runs in a managed environment. There's no need to manage and scale own servers.\footnote{https://firebase.google.com/docs/functions}
	\item \textbf{Realtime Database} - is a cloud-hosted database. Data is stored as JSON and synchronized in realtime to every connected client. When you build cross-platform apps with our Apple platforms, Android, and JavaScript SDKs, all of your clients share one Realtime Database instance and automatically receive updates with the newest data.\footnote{https://firebase.google.com/docs/database}
	\item \textbf{Authentication} - provides backend services, easy-to-use SDKs, and ready-made UI libraries to authenticate users to the app. It supports authentication using passwords, phone numbers, popular federated identity providers like Google, Facebook and Twitter, and more. Integrates tightly with other Firebase services, and it leverages industry standards like OAuth 2.0 and OpenID Connect, so it can be easily integrated with custom backend.\footnote{https://firebase.google.com/docs/auth}
	\item \textbf{Local Emulator Suite} - consists of individual service emulators built to accurately mimic the behavior of Firebase services. This means you can connect your app directly to these emulators to perform integration testing or QA without touching production data.\footnote{https://firebase.google.com/docs/emulator-suite}
	\item \textbf{Data Connect} - is a relational database service for mobile and web apps that lets developers build and scale using a fully-managed PostgreSQL database powered by Cloud SQL. It provides secure schema, query and mutation management using GraphQL technology that integrates well with Firebase Authentication. Developers can quickly integrate this product into the mobile and web apps with SDK support in Kotlin Android, iOS, Flutter, and web.\footnote{https://firebase.google.com/docs/data-connect}
	\item \textbf{Security Rules} - leverage extensible, flexible configuration languages to define what data users can access for Realtime Database, Cloud Firestore, and Cloud Storage. Firebase Realtime Database Security Rules leverage JSON in rule definitions, while Cloud Firestore Security Rules and Firebase Security Rules for Cloud Storage leverage a unique language built to accommodate more complex rules-specific structures. Developers can write simple or complex rules that protect the app's data to the level of granularity that the developer's specific app requires.\footnote{https://firebase.google.com/docs/rules}
	\item \textbf{App Check} - helps protect the app backends from abuse by preventing unauthorized clients from accessing the backend resources. It works with both Google services (including Firebase and Google Cloud services) and custom backends to keep resources safe.\footnote{https://firebase.google.com/docs/app-check}
	\item \textbf{Cloud Messaging} (FCM) is a cross-platform messaging solution that lets developers reliably send messages. It can notify a client app that new email or other data is available to sync. It can send notification messages to drive user re-engagement and retention. For use cases such as instant messaging, a message can transfer a payload of up to 4096 bytes to a client app.\footnote{https://firebase.google.com/docs/cloud-messaging}
	\item \textbf{Other Tools } - Firebase provides a several tools for monitoring the app with Firebase Crashlytics and Firebase Performance Monitoring, to engage the user with Google Analytics, Firebase In-App Messaging, Google AdMob, Google Ads and more.\footnote{https://firebase.google.com/docs/run}
\end{itemize}


To use Firebase there are two option in terms of Pricing Plans, the \textit{Spark Plan} which is the free plan, and the \textit{Blaze Plan} that is a pay as you go plan, meaning that, when passing a threshold in a specific feature, there is a cost associated.
Here are the limits\footnote{https://firebase.google.com/pricing}:
\begin{itemize}
	\item \textbf{Authentication} - there is no cost until 50k Monthly Active Users (MAUs), where with the Blaze Plan you pay more for each MAU where the maximum is 0.0025USD per extra MAU if there are more than 10,000,000.
	\item \textbf{Cloud Firestore} - the free version has 1GiB in Store data, 20k document writes per day, 50k document reads and 20k deletions. In the paid plan, when passin the limit the developer has to pay 0.039USD per 100,000 document reads, 0.117USD per 100,000 document writes, 0.013USD per 100,00 document deletions and 0.117 per GiB of storage per month, also having a backup data with 0.039USD per GiB.
	\item \textbf{Cloud Functions} - there is no cost until 2M invocations per month, and there are some limits for the procession power.
	\item \textbf{Cloud Storage} - it has 5GB in the free plan for storage, 1GB per day in download, 20k upload operations per day and 50K downloads. As for the paid plan, it cost 0.026USD per GB extra in storage, 0.12USD per GB extra downloaded and 0.05USD and 0.004USD per 10k upload and download operations respective.
	\item \textbf{Realtime database} - the free tier offers 1GB of storage and in the paid it is 5USD per GB extra.
\end{itemize}

\subsubsection{\textbf{Supabase}}

Supabase\footnote{https://supabase.com/} is an open-source alternative to the BaaS platform Firebase, as it is a combination of different open-source tools that are scalable\cite{ZewdieAyezabu2022}.
Supabase has the following tools:

\begin{itemize}
	\item \textbf{Database} - a Postgres database, available for every project. The relational struture is advantageous for performing complex queries, joins and full-text searches\cite{ZewdieAyezabu2022}.
	\item \textbf{Authentication} - makes it easy to implement authentication and authorization in the app. Supabase provides client SDKs and API endpoints to help create and manage users. Users can use many popular Auth methods, including password, magic link, one-time password (OTP), social login, and single sign-on (SSO).\footnote{https://supabase.com/docs/guides/auth}
	\item \textbf{Storage} - open source S3 Compatible Object Store that makes it simple to upload and serve files of any size, providing a robust framework for file access controls. It can store images, videos, documents, and any other file type. Serve assets with a global CDN to reduce latency from over 285 cities globally. Supabase Storage includes a built-in image optimizer, in order to resize and compress media files on demand\footnote{https://supabase.com/docs/guides/storage}.
	\item \textbf{Edge Functions} - server-side TypeScript functions, distributed globally at the edge â€” close to the users. They can be used for listening to webhooks or integrating the Supabase project with third-parties.\footnote{https://supabase.com/docs/guides/functions}
	\item \textbf{Realtime} - Supabase provides a globally distributed Realtime service that can send low-latency messages between clients, good for real-time messaging, database changes, cursor tracking, game events, and custom notifications. Track and synchronize user state across clients, ideal for showing who's online, or active participants. And listen to database changes in real-time.\footnote{https://supabase.com/docs/guides/realtime}
\end{itemize}

For features not natively provided by Supabase, such as push notifications or built-in analytics, developers can integrate third-party services, webhooks, or direct API integrations\footnote{https://supabase.com/partners/integrations}.

Supabase has 2 main plans, the free option and a pro option where the developer pays 25USD per month\footnote{https://supabase.com/pricing}.
Here what a developer gets with each plan:
\begin{itemize}
	\item \textbf{Database} - The free plan gets 500MB os database size, and the pro gets 8GB with option of paying more 0.125USD per extra GB. With the pro plan, the developer gets automatic backups of seven days, the project is never paused, has point of recovery for 100USD per month per 7 days retention, and more.
	\item \textbf{Authentication} - There are unlimited users, but in the free plan there is the limit of 50,000 Monthly Active Users (MAUs) and 100,000 MAUs for the pro plan, with the option of paying 0.00325USD per MAU extra. The pro plan has extra featuers.
	\item \textbf{Storage} - The free plan has 1GB include of storage while the paid has 100GB then 0.021USD per GB. The free plan has the max file upload size of 50MB and the paid has 500GB.
	\item \textbf{Realtime} - It has the current peak connection where in the free plan has 200 included and the pro plan has 500 with 10USD per 1000 more. The free has 2 Million messages per month included while the pro has 5 Million paing 2.50USD per Million extra.
	\item \textbf{Edge Functions} - The free plan has 500,000 invocations included while the pro plan as 2 Million with 2USD per Million extra.
\end{itemize}

\subsubsection{\textbf{Parse}}

Parse is an open-source Mobile Backend as a Service, that provides tools to develop the backend of mobile applications.
This option was from Facebook that decided to shut down and make it open-source and now, developers have to host the service, either in platforms that can manage Parse Server or self-host in a cloud service or in private servers\footnote{https://www.back4app.com/parse}.
Parse Platform has similar features has the other services, which are\footnote{https://parseplatform.org/\#features}:

\begin{itemize}
	\item \textbf{Database \& Storage} - Supports MongoDB and PostgreSQL for structured data, with flexible file storage options including Amazon S3, Google Cloud Storage, or local filesystem storage. GridFS is commonly used as the default large-file storage when MongoDB is chosen\footnote{https://www.mongodb.com/docs/manual/core/gridfs/}. Parse also supports multi-database deployments and can be configured to shard or separate concerns across databases for scale and isolation.
	\item \textbf{Real-time} - Live queries for real-time data updates and built-in push notification support across all platforms, with real time updates.
	\item \textbf{Authentication \& Security} - Provides comprehensive user management (signup, login, password reset) with support for OAuth, email verification, and custom authentication.
	\item \textbf{APIs \& Integration} - REST and GraphQL APIs with multi-platform SDKs for seamless integration across all major platforms. Supports custom queries and mutations.
	\item \textbf{Cloud Functions} - Allows server-side logic via custom Cloud Functions, database triggers that run on create/update/delete events, and background job processing for async or scheduled tasks.
	\item \textbf{Self-hosting Freedom} - Can be deployed anywhere that runs Node.js (cloud VMs, containers). Full control over infrastructure and data, with a Parse Dashboard for visual management and monitoring, guaranteing complete data ownership.
\end{itemize}

Parse platform and server are free and open-source, however, the cost lays in the hosting.

\subsubsection{\textbf{Back4App}}

Back4App is another MBaaS, cloud-hosted solution, that runs and hardened the open-source Parse Platform, exposing the same APIs and SDKs while adding management, scalability, backups and developer tools\footnote{https://www.back4app.com/product/parse-baas}.
With this platform, developers can take advantage of Parse functionalities while simplifying deployment and infrastructure management.
In terms of features, they are and work the same as the Parse, adding hosting, managing and UI features\footnote{https://www.back4app.com/}.
With Back4App there is no vendor lock-in, meaning that the developer can, anytime, export the database, files, Cloud code and run the same Parse Server elsewhere\cite{Back4AppAlternatives}.


In terms of pricing, the platform has a free plan, the MVP to ``Validate Ideas Quickly â€” Launch Fast on Our Managed Serverless Backend'' (15USD per month paying annually or 25USD monthly), Pay as you go to ``Run \& Scale Applications on a Serverless Infrastructure'' (80USD or 100USD per month) and the Dedicated to ``Production-Grade Speed, Isolation \& Flexibility on Dedicated Resources''(400USD or 500USD per month)\footnote{https://www.back4app.com/pricing/backend-as-a-service}.
Here are the differences:

\begin{itemize}
	\item \textbf{Request per month} - in the free plan is 25k requests, while the MVP is raised to 500k with 5USD per 100k extra request, the Pay as you go 5M with 2USD per 100k extra, and the last one is unlimited.
	\item \textbf{Data Storage }- the free plan has 250MB then is 1GB followed by 3GB and then 8GB, with 15USD monthly for each adicional gigabyte extra.
	\item \textbf{Data Transfer} - the free plan allows 1GB, the MVP is 250GB, the Pay as you go is 1TB and the Dedicated is 2TB, with 0.1USD per each 1GB of adicional transfer.
	\item \textbf{File Storage} - the free plan has 1GB, then 50GB, 250GB and 1TB, with 1USD charge per 10GB extra.
\end{itemize}

\subsubsection{\textbf{AWS Amplify}}

AWS Amplify is the Amazon's cloud-powered MBaas and developer toolchain that helps mobile developers build, deploy and scale fullstack applications.
It offers end-to-end workflows for developing, deploying and managing cross-platform apps, allowing seamless cloud integration.\footnote{https://docs.amplify.aws/android/}
Here are the features\footnote{https://aws.amazon.com/amplify/features/}:

\begin{itemize}
	\item \textbf{Authentication} - Create seamless on-boarding flows with a fully-managed user directory and pre-built sign-up, sign-in, forgot password, and multi-factor auth workflows. Amplify also supports login with a social provider such as Facebook, Google Sign-In, or Login With Amazon and provides fine grained access control to mobile and web applications. Powered by Amazon Cognito.
	\item \textbf{DataStore} - Use a multi-platform on-device persistent storage engine that automatically synchronizes data between mobile/desktop/web apps and the cloud, powered by GraphQL. DataStore provides a programming model for leveraging shared and distributed data without writing additional code for offline and online scenarios, which makes working with distributed, cross-user data just as simple as working with local-only data. Powered by AWS AppSync.
	\item \textbf{Analytics} - Understand the behavior of the iOS or Android users. Use auto tracking to track user sessions and web page metrics or create custom user attributes and in-app metrics. Provides access to real time data stream and developers can analyze the data for customer insights and build data driven marketing strategies to drive customer adoption, engagement, and retention. Powered by Amazon Pinpoint and Amazon Kinesis.
	\item \textbf{API } - Make secure HTTP requests to GraphQL and REST endpoints to access, manipulate, and combine data from one or more data sources such Amazon DynamoDB, Amazon Aurora Serverless, and the apps custom data sources with AWS Lambda. Amplify enables you to easily build scalable applications that require real-time updates, local data access for offline scenarios, and data synchronization with customizable conflict resolution when devices are back online. Powered by AWS AppSync and Amazon API Gateway.
	\item \textbf{Functions} - Add a Lambda function to the project which the developer can use alongside a REST API or as a datasource in the GraphQL API in the Amplify CLI. The developer can update the Lambda execution role policies for the function to access other resources generated and maintained by the CLI, using the CLI. Amplify CLI enables developers to create, test and deploy Lambda functions across various runtimes.
	\item \textbf{PubSub} - Pass messages between the app instances and the app's backend creating real-time interactive experiences. Amplify provides connectivity with cloud-based message-oriented middleware. Powered by AWS IoT services and Generic MQTT Over WebSocket Providers.
	\item \textbf{Push Notifications} - Improve customer engagement by using marketing and analytics capabilities. Leverage customer insights to segment and target the customers more effectively. The developer can tailor the content and communicate through multiple channels including email, texts as well as push notifications. Powered by Amazon Pinpoint.
	\item \textbf{Storage} - Store and manage user generated content such as photos, videos securely on device or in the cloud. The AWS Amplify Storage module provides a simple mechanism for managing user content for the app in public, protected or private storage buckets. Leverage cloud scale storage so that is easy to take the application from prototype to production. Powered by Amazon S3.
	\item \textbf{Predictions and Interactions} - Enhance the app by adding AI/ML capabilities and build interactive and engaging conversational bots with the same deep learning technologies that power Amazon Alexa.
\end{itemize}

AWS Amplify provides a comprehensive toolkit for application development, with open-source libraries, powered by AWS services and can be used with Amplify CLI and Amplify Studio or an existing AWS backend.
Amplify Studio brings a visual, collaborative environment for modeling data, managing users and creating backend resources.
With Amplify CLI toolchain, developers can configure and maintain backends.
And the ecosystem, also provides the Amplify UI Components, an open-source set of ready-to-use interface elements for authentication, storage and interactions that integrate directly with backend resources.\cite{awsAmplifyFeatures}


\begin{itemize}
	\item \textbf{Data Storage} - No cost up to 5 GB stored on CDN per month, then 0.023USD per GB per month.
	\item \textbf{Data Transfer Out} - Up to 15 GB per month at no cost, then 0.15USD per GB served for additional transfer.
	\item \textbf{Request Count (Server-Side Rendering)} - It covers up to 500,000 requests per month at no cost, then 0.30USD per 1 million requests thereafter.
	\item \textbf{Request Duration (SSR)} No cost up to 100 GB-hours per month, then 0.20USD per GB-hour.
	\item \textbf{Authentication powered by Amazon Cognito} - There are 3 plans, the Essentials, Plus and Lite that provides different features. In the Essencials, the first 10,000 monthly active users (MAUs) are for free, then is 0.0015USD per MAU. For the Plus, is cost 0.02USD per MAU. For the Lite plan, it has a free tier for the first 10,000 raising to 0.0055USD per MAU between 10,001 and 100,000. Then, until 1,000,000 is 0.0046USD per MAU, 0.00325 per MAU until 10,000,000 and greater than that is 0.0025USD.\footnote{https://aws.amazon.com/cognito/pricing/}
	\item \textbf{Real-time APIs powered by AWS AppSync} - 4.00USD per million Query and Data Modification Operations, 2.00USD per million Real-time Updates, 0.08USD per million minutes of connection to the AWS AppSync GraphQL service. There are different fees for cahing, starting at 0.044USD for 1 vCPU, 1.55GiB of memory and Low to moderate network performance to 6.775USD for 48vCPU, 317.77GiB of memory and 10Gigabit of network performance. The AppSync GraphQL Free Tier offers 250,000 query or data modification operations, 250,000 real-time updates and 600,000 connection-minutes.\footnote{https://aws.amazon.com/appsync/pricing/}
	\item \textbf{Data powered by Amazon DynamoDB} - Two pricing options available including on-demand and provisioned. DynamoDB on-demand mode is a serverless option with pay-per-request pricing and automatic scaling, with 0.705USD per million write request units (WCU) and 0.1415USD per million read request units (RCU), the first 25 GB stored per month is free using the DynamoDB Standard table class and 0.283USD per GB-month thereafter. With provisioned capacity mode, the developer must specify the number of reads and writes per second that expects the application to require, with 0.000735USD per WCU, 0.000147USD per RCU and the Data Storage is the same as the other plan.\footnote{https://aws.amazon.com/dynamodb/}
	\item \textbf{Functions powered by AWS Lambda} Lambda counts a request each time it starts executing in response to an event notification trigger, duration is calculated from the time the code begins executing until it returns or otherwise terminates, rounded up to the nearest 1 ms, with the price depends on the amount of memory the developer allocates to the function.\footnote{https://aws.amazon.com/lambda/pricing/}
	\item \textbf{Storage powered by Amazon Simple} - Pay only for what is used. There is no minimum charge. Amazon S3 cost components are storage pricing, request and data retrieval pricing, data transfer and transfer acceleration pricing, data management and insights feature pricing, replication pricing, and transform and query feature pricing.\footnote{https://aws.amazon.com/s3/pricing/}
\end{itemize}

\subsubsection{\textbf{Microsoft Azure}}

Microsoft Azure used to have Azure Mobile Services, and in 2016 Microsoft announced the transition to Azure App Service\footnote{https://azure.microsoft.com/en-us/blog/transition-of-azure-mobile-services/}.
Now, Azure does not provide a MBaaS like the other providers, but through multiple services in Azure App Service\footnote{https://azure.microsoft.com/en-us/products/app-service}.
Azure App Services provides a fully managed platform for building, hosting and scaling web and mobile applications backends using multiple programming languages\cite{azureappservices}.
It allows integrations with the following services:

\begin{itemize}
	\item \textbf{Azure Functions} - Execute event-driven serverless code that responds to HTTP requests, database changes or queue messages, with an end-to-end development experience for scalable APIs\cite{azureFunctions}.
	\item \textbf{Azure Cosmos DB} - A globally distributed, NoSQL database service that provides access to data with automatic scaling and multi-region replications. It supports several APIs, such asMongoDB, PostgreSQL and Apache Cassandra\footnote{https://learn.microsoft.com/en-us/azure/cosmos-db/introduction}
	\item \textbf{Azure SQL Database} - A fully managed relational Database as a Service that provides a fast, flexible and elastic SQL database\footnote{https://azure.microsoft.com/en-us/products/azure-sql/database}.
	\item \textbf{Microsoft Entra ID} - Formerly known as Azure Active Directory (Azure AD), this service manages identity and access, supporting OAuth2, OpenID Connect, and enterprise-grade authentications\footnote{https://www.microsoft.com/en-us/security/business/identity-access/microsoft-entra-id}.
	\item \textbf{Azure Notification Hubs} - A cross-platform push notification service that allows the delivery of personalized messages to mobile devices with support for tagging and segmentation\footnote{https://learn.microsoft.com/en-us/azure/notification-hubs/notification-hubs-push-notification-overview}.
	\item \textbf{Azure API Management} - Enables the creation, protection, and monitoring of APIs used by mobile applications. It provides rate limiting, authentication, analytic and developer portal capabilities\footnote{https://learn.microsoft.com/en-us/azure/api-management/api-management-key-concepts}.
	\item \textbf{Azure Storage} - Offers scalable object, file and queue storage options for unstructured data, media files, and backend integration, forming a common storage layer for mobile applications\footnote{https://learn.microsoft.com/en-us/azure/storage/common/storage-introduction}.
\end{itemize}

For the pricing, each service is billed independently, and has different plans for each services with multiple price variations, including different prices for different regions.

%\begin{itemize}
%	\item \textbf{Azure Functions} - Consumption Plan has 1 million free executions per month, 0.20USD per million additional executions,  400,000 GB-s free per month, 0.000016USD per GB-s. Flex Consumption: 250,000 free executions and 100,000 GB-s free per month, 0.000017USD per GB-s on-demand. Premium Plan: Starting at 116.80USD per vCPU/month and 8.979USD GB per month.
%	
%	\item \textbf{Azure Cosmos DB} - Serverless: 0.29USD per 1 million requests units (RUs), 0.25USD per GB storage/month. \textit{Provisioned Throughput (General Purpose):} \$0.00012 per 100 RU/s/hour; Storage \$0.25/GB/month. \textit{Free Tier:} 1,000 RU/s and 25 GB storage lifetime on one account.
%	
%	\item \textbf{Azure SQL Database} - \textit{vCore-based (General Purpose, 2 vCores):} \$0.504-\$0.5218/hour. \textit{Serverless Compute:} \$0.5218 per vCore-hour with auto-scaling. \textit{DTU-based (Standard S0):} \$0.006-\$0.024/hour. Storage \$0.10-\$0.30 per GB/month depending on tier.
%	
%	\item \textbf{Microsoft Entra ID} - \textit{Free Tier:} Included with Azure subscription. \textit{Premium P1:} \$6/user/month (annual commitment). \textit{Premium P2:} \$9/user/month (annual commitment). \textit{Microsoft Entra Suite:} \$12/user/month (annual commitment).
%	
%	\item \textbf{Azure Notification Hubs} - \textit{Free Tier:} 1 million pushes/month. \textit{Basic Tier:} \$10/month + \$1 per million pushes above 10 million. \textit{Standard Tier:} \$200/month with 10 million included pushes; \$10 per million (10-100M); \$2.50 per million (100M+).
%	
%	\item \textbf{Azure API Management} - \textit{Consumption Tier:} \$0.30-\$0.35 per 1 million operations. \textit{Basic v2:} \$150.01/month (10M requests included); \$0.40 per million additional. \textit{Standard v2:} \$700/month (50M requests included); \$0.25 per million additional. \textit{Premium v2:} Unlimited requests included.
%	
%	\item \textbf{Azure Storage} - \textit{Blob Storage (Hot Tier):} \$0.018-\$0.021 per GB/month (first 50TB), \$0.0135 per GB/month (50-500TB). \textit{Archive Tier:} \$0.00099 per GB/month. \textit{Queue Storage:} \$0.045 per GB/month. Operations: \$0.004 per 10,000 operations (write/read).
%\end{itemize}


\subsubsection{MBaaS Provider Comparison}

Table~\ref{tab:mbaasfeatures} presents a comprehensive comparison of the major MBaaS providers currently available in the market. The feature matrix demonstrates that modern MBaaS platforms have converged on a common set of core functionalities, including authentication mechanisms, real-time data synchronization capabilities, serverless computing through Cloud Functions, and comprehensive security rules. All evaluated providers offer APIs (both REST and GraphQL), file storage services, and offline support, reflecting the maturation and standardization of the MBaaS ecosystem.

However, significant differences emerge in the areas of database technology choices, open-source availability, and infrastructure control. Notably, Supabase distinguishes itself by offering only relational database technology (PostgreSQL), whereas other providers support both NoSQL and SQL databases, providing developers with flexibility in selecting the most appropriate data model for their application. Additionally, the degree of vendor lock-in varies considerably, with open-source solutions like Supabase and Parse offering greater portability and self-hosting capabilities, while proprietary platforms such as Firebase and AWS Amplify provide tightly integrated ecosystems with limited exit strategies.

\newcommand{\cmark}{\ding{51}}%
\newcommand{\xmark}{\ding{55}}%
\begin{table}[htbp]

	\footnotesize
	\label{tab:mbaasfeatures}
	\setlength{\tabcolsep}{3pt} 
	\renewcommand{\arraystretch}{1.3}
	\caption{Feature Matrix: MBaaS Providers Comparison}
	\begin{tabular}{|l|c|c|c|c|c|c|}
		\hline
		\rowcolor[gray]{0.9}
		\textbf{Feature} & \textbf{Firebase} & \textbf{Supabase} & \textbf{Parse} & \textbf{Back4App} & \textbf{AWS Amplify} & \textbf{Azure} \\
		\hline
		
		Auth & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark \\
		\hline
		
		Real-time Sync & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark \\
		\hline
		
		NoSQL DB & \makecell{Firestore,\\Realtime DB}  & \xmark & MongoDB & MongoDB & DynamoDB & Cosmos DB \\
		\hline
		
		SQL DB & Data Connect & PostgreSQL & PostgreSQL & PostgreSQL & Aurora & Azure SQL \\
		\hline
		
		Cloud Functions & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark \\
		\hline
		
		Push Notifications & \cmark & \xmark & \cmark & \cmark & \cmark & \cmark \\
		\hline
		
		APIs & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark \\
		\hline
		
		Storage & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark \\
		\hline
		
		Offline Support & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark \\
		\hline
		
		Analytics & \cmark & \xmark & \xmark & \cmark & \cmark & \xmark \\
		\hline
		
		DB Triggers & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark \\
		\hline
		
		Security Rules & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark \\
		\hline
		
		 Free Tier & Yes & Yes & Yes & Yes & Yes & Yes \\
		\hline
		
		Pricing Model & \makecell{Pay-as-you-go} & \makecell{Tiered} & \makecell{Self-host\\costs vary} & \makecell{Tiered} & \makecell{Pay-as-you-go\\per service} & \makecell{Pay-as-you-go\\per service} \\
		
		\hline

		\hline
		Observability & \makecell{Native} & \makecell{3rd Party)} & \makecell{External\\(self-hosted)} & \makecell{Limited\\(basic metrics)} & \makecell{Native} & \makecell{Native} \\
		\hline
		\makecell{Remote Config \\ (A/B testing) }& Native & 3rd Party & 3rd Party & 3rd Party & Native & Native \\

		\hline
		Data Location & Multi-EU & EU & Self-host & EU/US & Multi-EU & Multi-EU \\
		\hline
		Data Location & \makecell{Multi-Region\\(EU)} & \makecell{Single Region\\(EU)} & \makecell{Any\\(Self-Host)} & \makecell{Single/Multi\\(EU/US)} & \makecell{Multi-Region\\(EU)} & \makecell{Multi-Region\\(EU)} \\

		\hline
		GDPR Status & Certified & DPA & User Respons. & DPA & Certified & Certified \\
		\hline
		
		Open Source & \xmark & \cmark & \cmark & Partial & Partial & \xmark \\
		\hline
		
		Self-Hosting & \xmark & \cmark & \cmark & \xmark & \xmark & \xmark \\
		\hline
		
		Vendor Lock-in & High & Low & Low & Low & High & High \\
		\hline
		
	\end{tabular}
\end{table}



\section{Related Work}

To understand the existing solutions available in the Portuguese casual basketball market, it was conducted a search for applications and platforms addressing the challenges identified.
This section presents the research methodology and the identified applications.


\subsection{Methodology}
By searching the browser using the query ``Play basketball in Portugal'', the useful links found for someone who just want to go to a public court and play some casual games, or shoot some balls, where from a website called ``Courts of the World''\footnote{https://www.courtsoftheworld.com/}, ``Meetup''\footnote{https://www.meetup.com/find/portugal/}, a question in Reddit from 2021\footnote{https://www.reddit.com/r/lisboa/comments/qtokhf/anywhere\_to\_play\_pickup\_basketball\_in\_lisbon/}, a blog called ``World Baller''\footnote{https://www.worldballer.com/europe/lisbon}, and some websites for clubs and schools.
With the query ``Basketball pickup games Portugal'', the results were similar, with the AI from the browser telling to look for games in Facebook groups, in Meetup, and suggested 3 courts in Lisbon.

Using Perplexity AI, using this prompt in a deep research ``I am from Lisbon and I play basketball.
I would like to go play on the weekend in a public court.
Where can I go?
Is there any platform I can find some casual games to join?''\footnote{https://www.perplexity.ai/search/i-am-from-lisbon-and-i-play-ba-8VmBq1GuQFGTna4LnR3VXg\#0}, the model provided 4 public courts with a description, for example:

``Campo de Laranjeiras ("The Blue Court") near Laranjeiras Metro features two full courts with fresh surfaces and multiple hoops.
Locals refer to it as the "blue court" due to its bright surface colour.
It has a semi-competitive vibe with frequent rotation of players and is open 24/7 with free access.''

Besides that, it provided information about a group in Meetup, and a facebook group.
As for platforms, it indicated an app that does not available in Portugal, called ``Pickup: Connect \& Play Sports'', another called ``Pickup Sports (Adult League)''\footnote{https://pickup-sports.com/}.
Then it also shows ``Courts of the World'', that has an iOS application, and another app called ``Fullcourt: Pickup Basketball''\footnote{https://play.google.com/store/apps/details?id=com.fullcourt.fullcourt\&hl=en\_US}.

Using ChatGPT, with the same prompt, with the free version and the option of \textit{Web Search} activated, it answered with 8 public courts, with the Meetup group already mention above, as well as the facebook group, and the blog ``World Baller''\footnote{https://chatgpt.com/s/t\_68ef91bd97b881918a2f64248073502a}.
With the \textit{Thinking} option it provided some courts with the reference to ``Courts of the World'' website and the reddit question from above.
It also provided the same platforms, and gave some tips\footnote{https://chatgpt.com/s/t\_68ef915fde548191a794cd0d4dbdbd67}.

Another query made in the browser to explore ways for players to play casual basketball was ``\textit{reservar campos de basquetebol portugal}'' \footnote{book basketball courts portugal}, where it shows some private places to book, and a platform called ``AirCourts''\footnote{https://www.aircourts.com/}, that gathers different courts from different sports to help users book them.
In the website of AirCourts it was saying that they will join ``Playtomic''\footnote{https://playtomic.com/}, that is a platform to book courts and find players in padel and tennis.

In another search, ``\textit{Torneios amadores portugal basketball}''\footnote{Amateur tournaments Portugal basketball}, only one result from the first page would be useful for someone who wants to play casual basketball games, the website ``Jogabasket''\footnote{http://www.jogabasket.pt/}.

Going to the Google's Play Store, and searching for ``Pickup'' apps, several appeared, which Perplexity AI already mentioned, as well as, ``Pickup: Play \& Host Sports''\footnote{https://www.pickupgames.app/}\footnote{https://play.google.com/store/apps/details?id=com.testpickup.app}, ``GoodRec''\footnote{https://play.google.com/store/apps/details?id=com.lewisblack.JustPlay} (it is not available in Portugal), ``WOOOBA''\footnote{https://play.google.com/store/apps/details?id=io.woooba} and ``Pick-Roll''\footnote{https://play.google.com/store/apps/details?id=com.iperskill.pickroll}.

\subsection{Existing Projects}

It was found three categories of existing platforms relevant to casual basketball in Portugal: dedicated court discovery platforms, game organization platforms, general community platforms.

\subsubsection{Court Discovery Platforms}

\paragraph{\textbf{Courts of the World}}

Is a FIBA endorsed platform, available in web and in iOS, where users can find courts around the world.
The platform enables users to locate basketball courts nearby, see the mot popular ones, see court details and weather conditions, players can edit the court, added to their favourites or check-in, in order to register their present in the court.
It has a leaderbord for the top user that contribute for the platform, as they add courts, photos and comments.
The technical implementation of location-based services is unstable, often failing to load map data or local results, as tested in Lisbon and Porto. 
The platform also lacks user adherence, resulting in severe data obsolescence, for example, many popular courts show no activity (check-ins or media updates) for several years. 
This highlights a critical failure in their engagement as the system struggles to maintain the active user base necessary to keep data real-time and relevant.


\paragraph{\textbf{Jogabasket}}

From the part of the Portuguese Basketball Federation, this website has the same purpose as the Courts of the World.
In the home page, the user can find clubs, by searching a location, showing clubs as the result and their contacts.
The user can find some courts around Portugal with images, using a map that works fine.
There is also a section to find 3x3 tournaments, but, at the time of writing, there is nothing there.
This website is good for users to find courts in Portugal.

\subsubsection{Game Organization Platforms}


\paragraph{\textbf{Pickup Sports (Adult League)}} 

Pickup Sports is a cross-platform mobile application where users can find leagues of more than 15 sports, including basketball.
The platform allows users to join competitive leagues or participate in casual games with friends.
The application employs a location-based discovery mechanism and implements a monetization model where game organizers earn 75\% of fees collected from participants, with the remainder retained by the platform.
In Portugal, the application exhibited limited functionality and engagement. 
The location-based search mechanism did not return results for Portuguese cities, and no basketball games were available. 
User activity data showed minimal player presence and only in Los Angeles.
The application has more than 1,000 downloads in Play Store and less than 5,000 (last check in December 23 2025).

\paragraph{\textbf{Fullcourt: Pickup Basketball}}
	
	Fullcourt is a platform designed to organize and manage pickup basketball games.
	The application captures user profiles through physical attributes (height, weight, vertical jump), playing characteristics (position, skill level, and frequency), enabling users to match suitable players.
	The core functionality includes game creation and invitation management, where organizers select courts and times, and participants accept or decline invitations.
	The platform provides real-time visibility of game participants, their positions, attendance status, and includes in-game communication features.
	A courts map displays active player concentration and recurring weekly games (``Runs'') at specific locations.
	User engagement in Portugal is limited, with 10 registered users and a single mapped court location in Lisbon. 
	Player profiles include competitive statistics (win/loss records and game frequency), which are available for tracking individual performance metrics.
	The application has more than 10,000 downloads in Play Store and less than 50,000 (last check in December 23 2025).
	
\paragraph{\textbf{Pickup: Play \& Host Sports}} 

Pickup is a multi-sport platform that enables users to host and join games.
User profiles are established through sport selection and skill level specification.
The platform provides game discovery through search functionality (by sport and location) and game code entry, supplemented by a nearby games dashboard.
Game creation allows organizers to configure sport type, skill level, court type (public/private, indoor/outdoor), game format (individual or team-based), duration, player capacity, and visibility settings (public or private).
The platform includes a community feature enabling group formation, public communication, and member-organized games.
In the Portugal, the search and nearby games features returned no results, indicating absent game listings.
The platform maintains active communities in other regions (such as Hong Kong with 16 communities), but lacks established community presence in Portugal.
Additionally, newly created games did not appear in the application's discovery interface, suggesting potential functional issues or data synchronization problems.
The application has more than 500 downloads in Play Store and less than 1,000 (last check in December 23 2025).

\paragraph{\textbf{WOOOBA}}

WOOOBA is a basketball platform that facilitates game creation and participation. 
User profiles capture position preference, referee availability, age, and skill level, with configurable profile visibility settings. 
The platform supports both free and paid games, with the application retaining a commission on paid game transactions.
In Portugal, the platform showed no available games in Lisbon and Porto, indicating minimal user adoption and game availability in the region.
The application has more than 100 downloads in Play Store and less than 500 (last check in December 23 2025).

\paragraph{\textbf{Pick-Roll}} 

Pick-Roll is an Italian basketball platform centered on community engagement and competitive ranking.
The application implements a seasonal ranking system with leaderboard resets every three months and associated seasonal prizes. 
User accounts support two roles: individual players or team/minor organization owners.
Core features include court discovery through location-based mapping, game and event management (creation and participation), player check-in functionality to broadcast court presence, and peer rating systems.
The platform incorporates gamification elements including reputation points (``Fame'') earned through fair play, achievement-based medals for platform activities, and customizable player profiles featuring preferred equipment brands, interests, and team affiliations.
Seasonal participation requires a subscription fee after an initial two-month free trial period. 
Game creation offers two modes: standard and ranked games, with ranked participation restricted to active season members. 
In Portugal, the application shows no signs of use.
The application has 50,000 downloads in the Play Store an less than 100,000 (last check in December 23 2025).
	
\subsubsection{General Community Platforms}

\paragraph{\textbf{Meetup}} 

Meetup is a social media platform not only for sports, but where users can find groups for any type of activity, and, inside the group, the host can create events.
There is a group called ``Lisbon Basketball Club''\footnote{https://www.meetup.com/lisbon-basketball-meetup/} with 1942 members (last check in December 23 2025), that run indoor games every Monday and Sunday, paying a fee to book the court.


\subsection{Analysis of Existing Solutions}

Portuguese basketball players seeking to organize games currently rely on informal coordination methods or existing mobile platforms. 
Informal approaches include social media groups and in-person coordination at courts, alternatively, players can turn to dedicated applications designed specifically for organizing sports games".
However, for these platforms to function, including this project in development, they rely on user density, and a player installing one of these applications expects to discover available games organized by other users and to successfully organise games that attract sufficient participants, and if no users are active, the application is going to be deleted..
The analysis of existing platforms reveals a consistent pattern which show a minimal to absent user presence in Portugal.
Besides that, the majority of courts in Lisbon or Porto (only tested places) does not appear.
Another weakness found in the dedicated applications is that some core functionalities does not work properly, like the search mechanisms is inconsistent, and newly created games does not show where it should. 

These identified weaknesses in the other platforms translate into design opportunities for this project, such as, adopting a Portugal focus development having Portuguese users evaluating the iterations during development, and mapping as much courts as possible, adding a feature for users to contribute in the process.
In order to acquire users, a progressive, phased approach will be carried out, starting by focusing only in one region, having personal demonstrations in high peak hours in different courts in Lisbon, talking in groups and invest in tournaments in different courts where players are required to download the platform.
Besides that, the application development will prioritize the core features reliability and user experience, to encourage players to stay active.
The competitor platforms have features that can be use in this project to user retention, such as leaderboards, leagues and user achievements.
For now, the platform will not charge users, however, in the future some features that the analysed applications have to have revenue, may be integrated into the project, adding fees to be part of leagues with prizes, and booking private courts taking a percentage.
 








